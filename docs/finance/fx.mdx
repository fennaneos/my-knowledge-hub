---
id: fx
title: FX Volatility and Symmetry
sidebar_label: FX Volatility
---

# üí± FX Volatility and Symmetry

> *‚ÄúIn currencies, what goes down for one side, goes up for another.‚Äù*  
> ‚Äî **Principle of Symmetric Risk**

---

## üü° 1Ô∏è‚É£ Introduction ‚Äî The Dual Nature of FX

Unlike equities or credit assets, **foreign exchange (FX)** markets have **no natural ‚Äúupside‚Äù or ‚Äúdownside‚Äù**.  
Every exchange rate is a *relative price*:

$$
S_t = \frac{Value\ of\ 1\ Unit\ of\ Currency\ A}{Value\ of\ Currency\ B}.
$$

Thus, if EUR/USD rises, USD/EUR necessarily falls:

$$
S_t^{(EUR/USD)} = \frac{1}{S_t^{(USD/EUR)}}.
$$

From this simple identity, deep implications follow for **volatility**, **options**, and **risk symmetry**.

---

## ‚öñÔ∏è 2Ô∏è‚É£ The Reciprocity Principle

Let $$ S_t $$ denote an exchange rate and $$ X_t = 1/S_t $$ its reciprocal.  
By It√¥‚Äôs lemma:

$$
dX_t = -\frac{1}{S_t^2} dS_t + \frac{1}{S_t^3} (dS_t)^2
$$

If $$ S_t $$ follows a lognormal process under the risk-neutral measure $$ \mathbb{Q} $$:

$$
\frac{dS_t}{S_t} = (r_d - r_f) dt + \sigma_t dW_t,
$$

then $$ X_t = 1/S_t $$ satisfies:

$$
\frac{dX_t}{X_t} = (r_f - r_d) dt + \sigma_t dW_t',
$$

where $$ dW_t' = -dW_t $$.

**Conclusion:**  
Both processes share **the same instantaneous volatility** $$ \sigma_t $$. Hence, volatility is **invariant to currency inversion**.

---

## üíé 3Ô∏è‚É£ Symmetry of the Implied Volatility Surface

The **implied volatility surface** $$ \sigma_{imp}(K, T) $$ in FX must satisfy the *reciprocal symmetry* constraint:

$$
\sigma_{imp}(K,T; S_0)
=
\sigma_{imp}\!\left(\frac{S_0^2}{K},T; \frac{1}{S_0}\right).
$$

That is, the implied volatility for a strike $$ K $$ in USD/EUR  
is identical to that for $$ S_0^2 / K $$ in EUR/USD.

Mathematically, this implies the **volatility smile must be even** in log-moneyness:

$$
\ln\frac{K}{S_0} \;\; \to \;\; -\ln\frac{K}{S_0}.
$$

So:

$$
\sigma_{imp}(K,T) = f\!\left(\Big|\ln\frac{K}{S_0}\Big|\right),
$$

yielding a **U-shaped smile**, symmetric around the at-the-money (ATM) level.

![FX symmetry EUR/USD](./fx_symmetry_eurusd.png)

![FX symmetry USD/EUR](./fx_symmetry_usdeur.png)

![FX symmetry overlay log moneyness](./fx_symmetry_overlay_logmoneyness.png)


# üîÅ FX Reciprocal Symmetry in Implied Volatility

In **foreign exchange (FX)** markets, every currency pair has a **reciprocal quote**.  
For example, if:

$$
S_0 = \text{USD/EUR spot rate}, \quad \text{then} \quad \frac{1}{S_0} = \text{EUR/USD}.
$$

When quoting options, this duality imposes a **symmetry constraint** on the **implied volatility surface**:

$$
\sigma_{imp}(K, T; S_0)
=
\sigma_{imp}\!\left(\frac{S_0^2}{K}, T; \frac{1}{S_0}\right).
$$

---

## üß© Intuition

This property ensures that **pricing is invariant** whether you model options on  
USD/EUR or EUR/USD ‚Äî both must yield **the same no-arbitrage prices** when converted through the exchange rate.

In other words:

- A **call option** on USD/EUR with strike $$ K $$  
  must have the same implied volatility as  
  a **put option** on EUR/USD with strike $$ \frac{S_0^2}{K} $$.  
- Otherwise, there would be an **arbitrage opportunity** between the two mirrored FX options.

---

## ‚öôÔ∏è Mathematical Formulation

The price of an FX option under the domestic risk-neutral measure is:

$$
C_{FX}(K, T) = e^{-r_d T}\, \mathbb{E}^{\mathbb{Q}_d}[(S_T - K)^+],
$$

where:
- $$ r_d $$ = domestic interest rate  
- $$ r_f $$ = foreign interest rate  
- $$ S_T $$ = spot rate at maturity (domestic per foreign currency)

Under the **foreign measure** $$ \mathbb{Q}_f $$, the same option can be rewritten as:

$$
C_{FX}^{(f)}\!\left(\frac{S_0^2}{K}, T\right)
= e^{-r_f T}\, \mathbb{E}^{\mathbb{Q}_f}\!\left[\left(\frac{1}{S_T} - \frac{1}{K'}\right)^+\right],
$$

where $$ K' = \frac{S_0^2}{K} $$.

## üîÑ Why $$ K' = \frac{S_0^2}{K} $$

When switching from **USD/EUR** to **EUR/USD**, both the **underlying** and the **strike** must be transformed so that the option payoffs remain economically equivalent.

---

### 1Ô∏è‚É£ Start from the USD/EUR Call Option

A **call option on USD/EUR** gives the holder the right to buy 1 EUR for $$ K $$ USD at maturity:

$$
\text{Payoff}_{USD/EUR} = (S_T - K)^+,
$$

where:

- $$ S_T $$ = USD per EUR at maturity (the FX rate)
- $$ K $$ = strike in USD per EUR  

---

### 2Ô∏è‚É£ Express the Same Payoff in Terms of EUR/USD

Now, in the **EUR/USD world**, we quote the *inverse* exchange rate:

$$
\tilde{S}_T = \frac{1}{S_T} \quad \text{(EUR per USD)}.
$$

Then the payoff, denominated in EUR, becomes:

$$
\text{Payoff}_{EUR/USD}
= \left(\frac{1}{\tilde{S}_T} - K \right)^+
= \frac{1}{\tilde{S}_T} \left(1 - K \tilde{S}_T\right)^+.
$$

This looks like a **put option** on EUR/USD with strike:

$$
K' = \frac{1}{K}.
$$

But ‚Äî we must also scale by the **current spot rate** $$ S_0 $$ to keep the contract sizes consistent (since one contract is per EUR, the other per USD).

---

### 3Ô∏è‚É£ Adjust for the Change of Num√©raire

The two option markets (USD/EUR and EUR/USD) use different *notional units*:

- The USD/EUR option payoff is in **USD**.  
- The EUR/USD option payoff is in **EUR**.  

To make them *comparable under no-arbitrage*, we rescale the strike by $$ S_0^2 $$:

$$
K' = \frac{S_0^2}{K}.
$$

This ensures that the **value of the mirrored option** under the foreign measure
matches that under the domestic one when both are converted into the same currency.

---

### 4Ô∏è‚É£ Intuitive Check

If the current spot is $$ S_0 = 1.10 $$ (USD/EUR), and the USD/EUR call has strike $$ K = 1.20 $$:

Then the corresponding **EUR/USD** put option has strike:

$$
K' = \frac{1.10^2}{1.20} = 1.008.
$$

That means:  
A call on EUR/USD at 1.008 EUR per USD has the *same implied volatility* as the call on USD/EUR at 1.20 USD per EUR ‚Äî under the reciprocal symmetry condition.

---

### ‚úÖ Summary

| Concept | USD/EUR (domestic = USD) | EUR/USD (domestic = EUR) |
|:--|:--|:--|
| Spot | $$ S_0 $$ | $$ 1/S_0 $$ |
| Strike | $$ K $$ | $$ K' = S_0^2 / K $$ |
| Measure | $$ \mathbb{Q}_{USD} $$ | $$ \mathbb{Q}_{EUR} $$ |
| Relation |  |  |
| **Implied vol symmetry** |  | $$ \sigma_{imp}(K,T; S_0) = \sigma_{imp}(S_0^2/K,T; 1/S_0) $$ |

---

:::info üí°
The transformation $$ K' = S_0^2 / K $$ arises because switching between USD/EUR and EUR/USD  
involves **both inverting the rate** and **changing the currency num√©raire**, which requires a square scaling in the spot rate to maintain parity.
:::


By enforcing **no-arbitrage parity** between domestic and foreign measures, we derive:

$$
\sigma_{imp}(K, T; S_0)
=
\sigma_{imp}\!\left(\frac{S_0^2}{K}, T; \frac{1}{S_0}\right).
$$

---

## üí° Interpretation

- The **volatility smile** in FX must be **symmetric in log-moneyness**, unlike equities.  
- The reason is that in FX, **neither currency is the num√©raire by default** ‚Äî both can be chosen.  
- Pricing consistency requires this **reciprocal symmetry**, leading to symmetric smiles.  
- In contrast, equities exhibit **negative skew** because equity options are quoted in a **single num√©raire (cash)** and downside risk dominates.

---

:::info üîç Key Takeaway
FX implied volatility surfaces are **self-consistent under inversion** of the currency pair.
This symmetry constraint ensures **no-arbitrage** between USD/EUR and EUR/USD options.
:::

---

## Volatility Smile Formula (FX / Commodities)

Empirical studies (Derman, Dupire, Hagan) show that FX smiles can be modeled as:

$$
\sigma_{imp}(K,T)
=
\sigma_{ATM} + a \Big|\ln\frac{K}{S_0}\Big|^{\gamma},
$$

where:

| Parameter | Meaning |
|------------|----------|
| $$ \sigma_{ATM} $$ | At-the-money implied volatility |
| $$ a > 0 $$ | Smile amplitude |
| $$ \gamma \in [1,2] $$ | Curvature exponent (‚âà 1.5 for FX) |

The absolute value ensures *symmetry* in moneyness ‚Äî both far OTM calls and OTM puts exhibit higher implied vol.

---

## üß© Economic Intuition ‚Äî Why Symmetry Arises

| Source | Description | Volatility Effect |
|--------|-------------|------------------|
| **Two-sided exposure** | Every participant has long and short FX positions simultaneously (importers/exporters). | Both directions of price moves create risk. |
| **No natural ‚Äúcrash‚Äù direction** | Unlike equities, there‚Äôs no universal fear of a drop. | Volatility increases for both up/down extremes. |
| **Central bank actions** | Intervention risk exists for *appreciation* or *depreciation*. | Adds symmetric tail risk. |
| **Trade balance shocks** | Macroeconomic events can swing FX both ways. | Leads to smile-shaped implied vol. |

---

## üî¨ Comparison to Equities

| Market Type | Dominant Risk | Vol Shape | Economic Reason |
|--------------|----------------|-----------|-----------------|
| **Equities / Indices** | Downside (crash risk) | **Skew (negative slope)** | Put options expensive for crash protection |
| **FX / Commodities** | Two-sided macro risk | **Smile (symmetric U)** | Both appreciation and depreciation are risky |

In equities, investors are **net long** the underlying ‚Äî downside moves are feared.  
In FX, there‚Äôs no aggregate long or short; the market is **balanced** between counterparties.

---

## Relation to Black‚ÄìScholes with Two Rates

FX pricing uses **two interest rates**: domestic $$ r_d $$ and foreign $$ r_f $$.  
The forward price is:

$$
F_t(T) = S_t e^{(r_d - r_f)(T-t)}.
$$

The Black‚ÄìScholes price for a European call on FX is:

$$
C = S_t e^{-r_f (T-t)} N(d_1) - K e^{-r_d (T-t)} N(d_2),
$$

where:

$$
d_1 = \frac{\ln\frac{S_t}{K} + (r_d - r_f + 0.5\sigma^2)(T-t)}{\sigma \sqrt{T-t}},
\quad
d_2 = d_1 - \sigma\sqrt{T-t}.
$$

Notice the **symmetry**: if we swap $$ r_d \leftrightarrow r_f $$ and $$ S_t \leftrightarrow 1/S_t $$,  
we recover the same pricing relationship for the inverse currency pair.

---

## Reciprocity Proof in Option Pricing

Consider call and put prices in reciprocal pairs:

$$
C_d(S_t,K) = S_t e^{-r_f T} N(d_1) - K e^{-r_d T} N(d_2),
$$

$$
C_f(X_t,K') = X_t e^{-r_d T} N(d_1') - K' e^{-r_f T} N(d_2').
$$

With $$ X_t = 1/S_t, \; K' = 1/K, \; d_1' = -d_2, \; d_2' = -d_1 $$,  
we find:

$$
C_f(X_t,K') = \frac{C_d(S_t,K)}{S_t}.
$$

Thus, option prices are *scale-invariant*, enforcing symmetry in implied volatilities.

---

## Smile and Risk-Neutral Densities

The smile reflects the *non-lognormality* of the risk-neutral distribution.  
Let $$ q(K) $$ be the risk-neutral density of $$ S_T $$:

$$
\frac{\partial^2 C}{\partial K^2} = e^{-r_d T} q(K).
$$

A symmetric smile implies that $$ q(K) $$ is symmetric around $$ F_0 $$ in log-space:

$$
q\!\left(\frac{S_0^2}{K}\right) \propto q(K).
$$

In equities, however, the density is skewed (long left tail), producing a downward sloping vol curve.

---

## Volatility Surface in FX

A general FX implied volatility surface depends on both **strike** and **maturity**:

$$
\sigma_{imp}(K,T) = \sigma_{ATM}(T)
+ a(T) \left|\ln\frac{K}{F_0(T)}\right|^{\gamma(T)}.
$$

| Parameter | Description |
|------------|-------------|
| $$ a(T) $$ | Smile steepness (term-dependent) |
| $$ \gamma(T) $$ | Curvature ‚Äî often decreases with maturity |
| $$ \sigma_{ATM}(T) $$ | ATM term structure |

Smiles are steeper for **short-term** maturities (overnight, 1W, 1M) due to speculative flows  
and flatten for **long-term** maturities as mean-reversion dominates.

---

## Empirical Example ‚Äî EUR/USD Smile

| Strike (as % of Spot) | Observed IV (%) |
|-----------------------:|----------------:|
| 80% (deep OTM put) | 14.5 |
| 90% | 12.5 |
| 100% (ATM) | 11.0 |
| 110% | 12.4 |
| 120% (deep OTM call) | 14.8 |

Approximation:

$$
\sigma_{imp}(K) = 0.11 + 0.035 \Big|\ln\frac{K}{S_0}\Big|^{1.4}.
$$

Plot ‚Üí U-shaped curve symmetric around ATM.

---

## Connection to Local and Stochastic Vol Models

In local or stochastic volatility models, the smile arises naturally:

- **Local vol (Dupire):**  
  $$
  \sigma_{loc}^2(K,T)
  = \frac{\partial C / \partial T + (r_d - r_f) K \partial C / \partial K + r_f C}
  {0.5 K^2 \partial^2 C / \partial K^2}.
  $$
- **Heston model:** stochastic variance introduces skew and smile jointly.
- **SABR model:**  
  $$
  \sigma_{SABR}(F,K)
  = \frac{\alpha}{(F K)^{(1-\beta)/2}} \frac{z}{x(z)},
  $$
  where $$ z = \frac{\nu}{\alpha} (F K)^{(1-\beta)/2} \ln(F/K) $$.

For FX, SABR with small $$ \rho \approx 0 $$ produces **symmetric smiles**,  
while equities with $$ \rho < 0 $$ produce **negative skews**.

---

## üè¶ Why Smile = Stability Indicator

- A **flat smile** ‚Üí stable, liquid FX pair (EUR/USD).  
- A **steep smile** ‚Üí high uncertainty (emerging markets, commodities).  
- During crises, smile steepens symmetrically ‚Äî both appreciation and depreciation tails widen.

---

## üß≠ Summary Table

| Market | Shape | Symmetry | Drivers | Example |
|:--------|:------|:----------|:---------|:----------|
| **FX (EUR/USD)** | Smile | Symmetric | Policy risk both sides | ECB vs Fed actions |
| **Commodities (Oil)** | Smile | Approx. symmetric | Physical scarcity & shocks | Brent, Gold |
| **Equities (S&P 500)** | Skew | Asymmetric (left) | Crash fear | Downside puts expensive |
| **Rates (Swaptions)** | Mixed | Varies by tenor | Yield curve convexity | 10Y payer skew |

---

## üß© Practical Takeaways

- FX volatility surfaces are **mirror symmetric** due to currency reciprocity.
- The smile shape reflects **two-sided risk** ‚Äî appreciation and depreciation both dangerous.
- Equity markets differ: downside protection dominates ‚Üí **negative skew**.
- Quantitative models (SABR, Heston) reproduce both shapes by tuning **correlation œÅ**:
  - $$ œÅ \approx 0 $$: FX-style smile  
  - $$ œÅ < 0 $$: Equity-style skew

---

## üîó Optional Appendix ‚Äî Symmetry Proof Sketch

Under lognormal assumption,  
if option price $$ C(S_0,K) $$ satisfies put‚Äìcall duality:

$$
C(S_0,K) = S_0 e^{-r_f T} P(1/S_0,1/K),
$$

then differentiating twice in $$ K $$ yields:

$$
\frac{\partial^2 C(S_0,K)}{\partial K^2} = e^{-r_d T} q(K),
\quad
\frac{\partial^2 P(1/S_0,1/K)}{\partial (1/K)^2} = e^{-r_f T} q(1/K).
$$

Consistency requires $$ q(K) \propto q(1/K) $$,  
which implies symmetric tails and thus a smile.

---

## Mathematical Summary

| Concept | Expression | Key Property |
|----------|-------------|---------------|
| Reciprocal Symmetry | $$ S \leftrightarrow 1/S $$ | $$ \sigma(K,T) = \sigma(S_0^2/K,T) $$ |
| Log-moneyness variable | $$ x = \ln(K/S_0) $$ | Smile ‚Üí even function of $$ x $$ |
| FX BS Formula | $$ C = S e^{-r_f T}N(d_1) - K e^{-r_d T}N(d_2) $$ | Two rates appear |
| Smile Parametric Model | See formula below | Symmetric by construction |

$$
\sigma_{\mathrm{imp}} \;=\; \sigma_{\mathrm{ATM}} \;+\; a \,\lvert x \rvert^{\gamma}.
$$


---

## üèÅ Final Words

> In FX, volatility smiles are not anomalies ‚Äî they are the **inevitable reflection of reciprocal risk**.  
> Unlike equities, currencies live in a world where **every move cuts both ways**.

---

üñ§ **Designed for the LuxQuant Volatility Handbook**  
Gold-on-black edition ‚ú®


import TryIt from '@site/src/components/tryit/TryIt';

## 9. Practical Lab ‚Äî FX Symmetry (10 mini exercises)

<TryIt
  id="fx-lab"
  chapterId="fx"
  title="FX Volatility & Symmetry ‚Äî Lab"
  intro="Implement the functions described below, then click Run tests. Each exercise has 2 tests; all ten together total 3‚òÖ."
  starTotal={3}
  packWeight={0.3}
  packs={[
    {
      id: 'fwd',
      name: '‚≠ê FX Forward (rd ‚àí rf)',
      detect: "def\\s+fx_forward\\s*\\(",
      question: `Implement fx_forward(S, rd, rf, T) returning the FX forward:
F = S * exp((rd - rf) * T).`,
      scaffold: `import math

def fx_forward(S, rd, rf, T):
    """Return F = S * exp((rd - rf) * T)."""
    # TODO
    return 0
`,
      hint: `F = S * exp((rd - rf) * T). Use math.exp.`,
      weight: 0.3,
      tests: [
        {
          expr: ['import math','S=1.10; rd=0.04; rf=0.02; T=1','fx_forward(S,rd,rf,T)'].join('; '),
          expected: Number((1.10 * Math.exp((0.04-0.02)*1)).toFixed(6)),
          tol: 1e-6,
        },
        {
          expr: ['import math','S=0.95; rd=0.01; rf=0.03; T=2','fx_forward(S,rd,rf,T)'].join('; '),
          expected: Number((0.95 * Math.exp((0.01-0.03)*2)).toFixed(6)),
          tol: 1e-6,
        },
      ],
    },

    {
      id: 'inv',
      name: '‚≠ê Reciprocal Rate',
      detect: "def\\s+invert_rate\\s*\\(",
      question: `Implement invert_rate(S) that returns 1/S (the reciprocal quote).`,
      scaffold: `def invert_rate(S):
    """Return 1/S (reciprocal FX rate)."""
    # TODO
    return 0.0
`,
      hint: `Just return 1.0 / S.`,
      weight: 0.3,
      tests: [
        { expr: 'invert_rate(1.20)', expected: Number((1/1.20).toFixed(6)), tol: 1e-6 },
        { expr: 'invert_rate(0.95)', expected: Number((1/0.95).toFixed(6)), tol: 1e-6 },
      ],
    },

    {
      id: 'mirrorK',
      name: '‚≠ê Mirrored Strike K‚Ä≤=S0¬≤/K',
      detect: "def\\s+mirror_strike\\s*\\(",
      question: `Implement mirror_strike(S0, K) that returns K' = S0**2 / K (strike mapping under reciprocal symmetry).`,
      scaffold: `def mirror_strike(S0, K):
    """Return mirrored strike K' = S0**2 / K."""
    # TODO
    return 0.0
`,
      hint: `K_prime = (S0**2) / K.`,
      weight: 0.3,
      tests: [
        { expr: 'mirror_strike(1.10, 1.20)', expected: Number(((1.10**2)/1.20).toFixed(6)), tol: 1e-6 },
        { expr: 'mirror_strike(0.90, 1.05)', expected: Number(((0.90**2)/1.05).toFixed(6)), tol: 1e-6 },
      ],
    },

    {
      id: 'call',
      name: '‚≠ê FX Black‚ÄìScholes Call',
      detect: "def\\s+call_fx_bs\\s*\\(",
      question: `Implement call_fx_bs(S, K, T, rd, rf, sigma) using FX BS:
C = S*e^{-rf T} N(d1) - K*e^{-rd T} N(d2),
d1 = [ln(S/K) + (rd - rf + 0.5 œÉ¬≤)T] / (œÉ‚àöT), d2=d1-œÉ‚àöT.`,
      scaffold: `import math

def _Nd(x):
    # standard normal CDF N(x)
    return 0.5 * (1.0 + math.erf(x / math.sqrt(2.0)))

def call_fx_bs(S, K, T, rd, rf, sigma):
    """FX Black‚ÄìScholes call price with two rates."""
    # TODO: implement per formula (use _Nd for N)
    return 0.0
`,
      hint: `Compute d1, d2, then S*exp(-rf*T)*N(d1) - K*exp(-rd*T)*N(d2).`,
      weight: 0.3,
      tests: [
        {
          expr: [
            'import math',
            'S=1.10; K=1.05; T=1.0; rd=0.02; rf=0.01; sigma=0.20',
            'call_fx_bs(S,K,T,rd,rf,sigma)'
          ].join('; '),
          expected: (() => {
            const S=1.10,K=1.05,T=1,rd=0.02,rf=0.01,s=0.20;
            const d1=(Math.log(S/K)+(rd-rf+0.5*s*s)*T)/(s*Math.sqrt(T));
            const d2=d1-s*Math.sqrt(T);
            const Nd=(x)=>0.5*(1+erf(x/Math.SQRT2));
            function erf(x){ // quick erf
              // Abramowitz-Stegun approximation
              const a1=0.254829592,a2=-0.284496736,a3=1.421413741,a4=-1.453152027,a5=1.061405429,p=0.3275911;
              const sign=x<0?-1:1; const t=1/(1+p*Math.abs(x));
              const y=1-((((a5*t+a4)*t+a3)*t+a2)*t+a1)*t*Math.exp(-x*x);
              return sign*y;
            }
            return Number((S*Math.exp(-rf*T)*Nd(d1) - K*Math.exp(-rd*T)*Nd(d2)).toFixed(6));
          })(),
          tol: 1e-4,
        },
        {
          expr: [
            'import math',
            'S=0.95; K=1.00; T=0.5; rd=0.03; rf=0.02; sigma=0.15',
            'call_fx_bs(S,K,T,rd,rf,sigma)'
          ].join('; '),
          expected: (() => {
            const S=0.95,K=1.00,T=0.5,rd=0.03,rf=0.02,s=0.15;
            const d1=(Math.log(S/K)+(rd-rf+0.5*s*s)*T)/(s*Math.sqrt(T));
            const d2=d1-s*Math.sqrt(T);
            const Nd=(x)=>0.5*(1+erf(x/Math.SQRT2));
            function erf(x){const a1=0.254829592,a2=-0.284496736,a3=1.421413741,a4=-1.453152027,a5=1.061405429,p=0.3275911;const sign=x<0?-1:1;const t=1/(1+p*Math.abs(x));const y=1-((((a5*t+a4)*t+a3)*t+a2)*t+a1)*t*Math.exp(-x*x);return sign*y;}
            return Number((S*Math.exp(-rf*T)*Nd(d1) - K*Math.exp(-rd*T)*Nd(d2)).toFixed(6));
          })(),
          tol: 1e-4,
        },
      ],
    },

    {
      id: 'put-parity',
      name: '‚≠ê Put from Call (FX Parity)',
      detect: "def\\s+put_from_call_parity_fx\\s*\\(",
      question: `Implement put_from_call_parity_fx(C, S, K, rd, rf, T):
P = C - (S*e^{-rf T} - K*e^{-rd T}).`,
      scaffold: `import math

def put_from_call_parity_fx(C, S, K, rd, rf, T):
    """Return put from call using FX parity."""
    # TODO
    return 0.0
`,
      hint: `P = C - (S*exp(-rf*T) - K*exp(-rd*T)).`,
      weight: 0.3,
      tests: [
        {
          expr: [
            'import math',
            'S=1.10; K=1.05; T=1; rd=0.02; rf=0.01; sigma=0.20',
            '_Nd=lambda x: 0.5*(1+math.erf(x/math.sqrt(2)))',
            'd1=(math.log(S/K)+(rd-rf+0.5*sigma*sigma)*T)/(sigma*math.sqrt(T))',
            'd2=d1-sigma*math.sqrt(T)',
            'C = S*math.exp(-rf*T)*_Nd(d1) - K*math.exp(-rd*T)*_Nd(d2)',
            'put_from_call_parity_fx(C,S,K,rd,rf,T)'
          ].join('; '),
          expected: (() => {
            const S=1.10,K=1.05,T=1,rd=0.02,rf=0.01,s=0.20;
            const d1=(Math.log(S/K)+(rd-rf+0.5*s*s)*T)/(s*Math.sqrt(T));
            const d2=d1-s*Math.sqrt(T);
            const Nd=(x)=>0.5*(1+erf(x/Math.SQRT2));
            function erf(x){const a1=0.254829592,a2=-0.284496736,a3=1.421413741,a4=-1.453152027,a5=1.061405429,p=0.3275911;const sign=x<0?-1:1;const t=1/(1+p*Math.abs(x));const y=1-((((a5*t+a4)*t+a3)*t+a2)*t+a1)*t*Math.exp(-x*x);return sign*y;}
            const C=S*Math.exp(-rf*T)*Nd(d1) - K*Math.exp(-rd*T)*Nd(d2);
            const P=C - (S*Math.exp(-rf*T) - K*Math.exp(-rd*T));
            return Number(P.toFixed(6));
          })(),
          tol: 1e-4,
        },
        {
          expr: [
            'import math',
            'S=0.98; K=1.00; T=0.75; rd=0.015; rf=0.01; sigma=0.18',
            '_Nd=lambda x: 0.5*(1+math.erf(x/math.sqrt(2)))',
            'd1=(math.log(S/K)+(rd-rf+0.5*sigma*sigma)*T)/(sigma*math.sqrt(T))',
            'd2=d1-sigma*math.sqrt(T)',
            'C = S*math.exp(-rf*T)*_Nd(d1) - K*math.exp(-rd*T)*_Nd(d2)',
            'put_from_call_parity_fx(C,S,K,rd,rf,T)'
          ].join('; '),
          expected: (() => {
            const S=0.98,K=1.00,T=0.75,rd=0.015,rf=0.01,s=0.18;
            const d1=(Math.log(S/K)+(rd-rf+0.5*s*s)*T)/(s*Math.sqrt(T));
            const d2=d1-s*Math.sqrt(T);
            const Nd=(x)=>0.5*(1+erf(x/Math.SQRT2));
            function erf(x){const a1=0.254829592,a2=-0.284496736,a3=1.421413741,a4=-1.453152027,a5=1.061405429,p=0.3275911;const sign=x<0?-1:1;const t=1/(1+p*Math.abs(x));const y=1-((((a5*t+a4)*t+a3)*t+a2)*t+a1)*t*Math.exp(-x*x);return sign*y;}
            const C=S*Math.exp(-rf*T)*Nd(d1) - K*Math.exp(-rd*T)*Nd(d2);
            const P=C - (S*Math.exp(-rf*T) - K*Math.exp(-rd*T));
            return Number(P.toFixed(6));
          })(),
          tol: 1e-4,
        },
      ],
    },

    {
      id: 'put',
      name: '‚≠ê FX Black‚ÄìScholes Put',
      detect: "def\\s+put_fx_bs\\s*\\(",
      question: `Implement put_fx_bs(S, K, T, rd, rf, sigma):
P = K e^{-rd T} N(-d2) - S e^{-rf T} N(-d1).`,
      scaffold: `import math

def _Nd(x):
    return 0.5 * (1.0 + math.erf(x / math.sqrt(2.0)))

def put_fx_bs(S, K, T, rd, rf, sigma):
    """FX Black‚ÄìScholes put price with two rates."""
    # TODO
    return 0.0
`,
      hint: `Use d1/d2 as in the call; then K e^{-rdT} N(-d2) - S e^{-rfT} N(-d1).`,
      weight: 0.3,
      tests: [
        {
          expr: [
            'import math',
            'S=1.10; K=1.05; T=1.0; rd=0.02; rf=0.01; sigma=0.20',
            'put_fx_bs(S,K,T,rd,rf,sigma)'
          ].join('; '),
          expected: (() => {
            const S=1.10,K=1.05,T=1,rd=0.02,rf=0.01,s=0.20;
            const d1=(Math.log(S/K)+(rd-rf+0.5*s*s)*T)/(s*Math.sqrt(T));
            const d2=d1-s*Math.sqrt(T);
            const Nd=(x)=>0.5*(1+erf(x/Math.SQRT2));
            function erf(x){const a1=0.254829592,a2=-0.284496736,a3=1.421413741,a4=-1.453152027,a5=1.061405429,p=0.3275911;const sign=x<0?-1:1;const t=1/(1+p*Math.abs(x));const y=1-((((a5*t+a4)*t+a3)*t+a2)*t+a1)*t*Math.exp(-x*x);return sign*y;}
            const P=K*Math.exp(-rd*T)*Nd(-d2) - S*Math.exp(-rf*T)*Nd(-d1);
            return Number(P.toFixed(6));
          })(),
          tol: 1e-4,
        },
        {
          expr: [
            'import math',
            'S=1.02; K=1.05; T=0.5; rd=0.03; rf=0.02; sigma=0.25',
            'put_fx_bs(S,K,T,rd,rf,sigma)'
          ].join('; '),
          expected: (() => {
            const S=1.02,K=1.05,T=0.5,rd=0.03,rf=0.02,s=0.25;
            const d1=(Math.log(S/K)+(rd-rf+0.5*s*s)*T)/(s*Math.sqrt(T));
            const d2=d1-s*Math.sqrt(T);
            const Nd=(x)=>0.5*(1+erf(x/Math.SQRT2));
            function erf(x){const a1=0.254829592,a2=-0.284496736,a3=1.421413741,a4=-1.453152027,a5=1.061405429,p=0.3275911;const sign=x<0?-1:1;const t=1/(1+p*Math.abs(x));const y=1-((((a5*t+a4)*t+a3)*t+a2)*t+a1)*t*Math.exp(-x*x);return sign*y;}
            const P=K*Math.exp(-rd*T)*Nd(-d2) - S*Math.exp(-rf*T)*Nd(-d1);
            return Number(P.toFixed(6));
          })(),
          tol: 1e-4,
        },
      ],
    },

    {
      id: 'fwd-prod',
      name: '‚≠ê Forward Reciprocity (Product = 1)',
      detect: "def\\s+forward_product_one\\s*\\(",
      question: `Implement forward_product_one(S0, rd, rf, T) that returns
fx_forward(S0,rd,rf,T) * fx_forward(1/S0, rf, rd, T).
It should be ‚âà 1 by reciprocity.`,
      scaffold: `import math

def forward_product_one(S0, rd, rf, T):
    """Return F_dom * F_for where F_dom = S0 e^{(rd-rf)T}, F_for = (1/S0) e^{(rf-rd)T}."""
    # TODO
    return 0.0
`,
      hint: `Compute F1 = S0*exp((rd-rf)*T) and F2 = (1/S0)*exp((rf-rd)*T); return F1*F2.`,
      weight: 0.3,
      tests: [
        {
          expr: 'forward_product_one(1.10, 0.03, 0.01, 2.0)',
          expected: Number((1.0).toFixed(6)),
          tol: 1e-6,
        },
        {
          expr: 'forward_product_one(0.92, 0.015, 0.025, 3.5)',
          expected: Number((1.0).toFixed(6)),
          tol: 1e-6,
        },
      ],
    },

    {
      id: 'mirror-invert',
      name: '‚≠ê Mirror Then Mirror Back',
      detect: "def\\s+mirror_then_back\\s*\\(",
      question: `Implement mirror_then_back(S0, K) that computes K' = S0**2/K,
then K'' = S0**2/K', and returns |K'' ‚àí K|. It should be ‚âà 0.`,
      scaffold: `def mirror_then_back(S0, K):
    """Return absolute error after mirroring twice (should be ~0)."""
    # TODO
    return 0.0
`,
      hint: `Kp = S0**2 / K; Km = S0**2 / Kp; return abs(Km - K).`,
      weight: 0.3,
      tests: [
        { expr: 'mirror_then_back(1.10, 1.25)', expected: 0.0, tol: 1e-12 },
        { expr: 'mirror_then_back(0.97, 0.85)', expected: 0.0, tol: 1e-12 },
      ],
    },

    {
      id: 'logm',
      name: '‚≠ê |log-moneyness|',
      detect: "def\\s+log_moneyness_abs\\s*\\(",
      question: `Implement log_moneyness_abs(S0, K) that returns |ln(K/S0)| (the symmetric log-moneyness used in FX smiles).`,
      scaffold: `import math

def log_moneyness_abs(S0, K):
    """Return abs(log(K/S0))."""
    # TODO
    return 0.0
`,
      hint: `Use math.log and abs.`,
      weight: 0.3,
      tests: [
        { expr: 'log_moneyness_abs(1.00, 1.10)', expected: Number((Math.abs(Math.log(1.10/1.00))).toFixed(12)), tol: 1e-10 },
        { expr: 'log_moneyness_abs(1.00, 0.90)', expected: Number((Math.abs(Math.log(0.90/1.00))).toFixed(12)), tol: 1e-10 },
      ],
    },

    {
      id: 'smile',
      name: '‚≠ê Symmetric Smile Model',
      detect: "def\\s+smile_sigma\\s*\\(",
      question: `Implement smile_sigma(sigma_atm, a, gamma, S0, K):
œÉ = œÉ_ATM + a * |ln(K/S0)|^Œ≥`,
      scaffold: `import math

def smile_sigma(sigma_atm, a, gamma, S0, K):
    """Return sigma_atm + a * |ln(K/S0)|**gamma."""
    # TODO
    return 0.0
`,
      hint: `Compute x = abs(log(K/S0)); return sigma_atm + a*(x**gamma).`,
      weight: 0.3,
      tests: [
        {
          expr: 'smile_sigma(0.11, 0.035, 1.4, 1.00, 1.20)',
          expected: Number((0.11 + 0.035*Math.pow(Math.abs(Math.log(1.20/1.00)), 1.4)).toFixed(12)),
          tol: 1e-10,
        },
        {
          expr: 'smile_sigma(0.11, 0.035, 1.4, 1.00, 0.80)',
          expected: Number((0.11 + 0.035*Math.pow(Math.abs(Math.log(0.80/1.00)), 1.4)).toFixed(12)),
          tol: 1e-10,
        },
      ],
    },

    {
      id: 'drift-foreign',
      name: '‚≠ê Drift Under Foreign Measure',
      detect: "def\\s+foreign_measure_drift\\s*\\(",
      question: `Implement foreign_measure_drift(rd, rf) returning (rf ‚àí rd), the drift of S under the foreign measure.`,
      scaffold: `def foreign_measure_drift(rd, rf):
    """Return rf - rd."""
    # TODO
    return 0.0
`,
      hint: `Just rf - rd.`,
      weight: 0.3,
      tests: [
        { expr: 'foreign_measure_drift(0.03, 0.01)', expected: -0.02, tol: 1e-12 },
        { expr: 'foreign_measure_drift(0.01, 0.025)', expected: 0.015, tol: 1e-12 },
      ],
    },
  ]}
/>
